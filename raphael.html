<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <title>Voronoy diagrams</title>
    <script type="text/javascript" charset="utf-8" src="js/raphael.max.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/ex_path.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/voronoy.js"></script>
    <style type="text/css" media="screen">
      body, body * {
        margin: 0;
        padding: 0;
      }
      body {
        background-color: #000;
      }
    </style>
  </head>
  <body>
    <div id="page">
      <div id="paper"></div>
    </div>
    <script type="text/javascript" charset="utf-8">
      
      (function() {
        
        
        var paper,
            sites,
            bbox,
            voronoi,
            paths,
            last_mouse_pos,
            bg_data,
            closest_center_line,
            closest_site;
        
        document.addEventListener( "DOMContentLoaded", initialize, false );
        window.addEventListener( "resize", function() {
          resetPaper();
          redraw();
        }, false );
        window.addEventListener( "mousemove", function( e ) {
          last_mouse_pos = { x: e.x, y: e.y };
          // sites[ sites.length - 1 ] = last_mouse_pos;
          redraw();
        }, false );
      
        function resetPaper() {
          
          paper = Raphael(
            "paper",
            window.innerWidth,
            window.innerHeight
          );
          
          bbox = {
        		xl: 0,
        		xr: paper.width,
        		yt: 0,
        		yb: paper.height
        	};
          
          paths = [];
          
          sites = generateBeeHivePoints( { x: 4.0, y: 3.0 }, true );
        }
        
        function initialize() {
          
          resetPaper();
          
          addPattern( "img/vw.jpg", "template1" );
          addPattern( "img/1.jpg", "template2" );
          addPattern( "img/3.png", "template3" );
          addPattern( "img/ipad_1.png", "template4" );
          addPattern( "img/s4.jpg", "template5" );
          addPattern( "img/w1.jpg", "template6" );
          addPattern( "img/w3.jpg", "template7" );
          addPattern( "img/w5.jpg", "template8" );
          addPattern( "img/w6.jpg", "template9" );
          addPattern( "img/w7.jpg", "template10" );
          addPattern( "img/w8.jpg", "template11" );
          addPattern( "img/w9.jpg", "template12" );
          
          voronoi = new Voronoi();
          
          last_mouse_pos = { x: paper.width / 2, y: paper.height / 2 };
          
          // sites.push( last_mouse_pos );
          redraw();
        }
      
        function redraw() {
          draw();
        }
      
        var xlink = "http://www.w3.org/1999/xlink",
        $ = function (el, attr) {
            if (attr) {
                if (typeof el == "string") {
                    el = $(el);
                }
                for (var key in attr) if (attr.hasOwnProperty(key)) {
                    if (key.substring(0, 6) == "xlink:") {
                        el.setAttributeNS(xlink, key.substring(6), String(attr[key]));
                    } else {
                        el.setAttribute(key, String(attr[key]));
                    }
                }
            } else {
                el = Raphael._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
                el.style && (el.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
            }
            return el;
        }
        
        
        function addPattern( img_src, id ) {
          var canvas = paper.canvas,
              doc = canvas.ownerDocument,
              namespaceUri = canvas.namespaceURI,
              defs = paper.defs,
              el = $("pattern"),
              ig = $("image");
              el.id = id;
              $(el, {x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1});
              $(ig, {x: 0, y: 0, "xlink:href": img_src});
              el.appendChild(ig);
          
          (function (el) {
              Raphael._preload(img_src, function () {
                  var w = this.offsetWidth,
                      h = this.offsetHeight;
                  $(el, {width: w, height: h});
                  $(ig, {width: w, height: h});
              });
          })(el);
          
          defs.appendChild( el );
          
          return el.id;
        }
        
        
        function draw() {
          var diagram = voronoi.compute(sites, bbox);
          
        	if (diagram) {
        	  
        	  var current_ids = [],
        	      last_path,
        	      index = 1,
        	      closest_distance;
        	  
        	  if ( undefined !== closest_center_line && null !== closest_center_line ) {
        	    closest_center_line.remove();
        	  }
        	  
        	  for ( ix in paths ) {
        	    current_ids.push( parseInt( ix, 10 ) );
        	  }
        	  
        	  for ( var i = 0; i < sites.length; i++ ) {
        	    var site = sites[ i ];
        	    if (
                site.x > paper._left &&
                site.x < paper._left + paper.width &&
                site.y > paper._top &&
                site.y < paper._top + paper.height
              ) {
                if ( last_mouse_pos !== null && i != ( sites.length - 1 ) ) {
                  var pointer_distance = Math.pow( last_mouse_pos.x - site.x, 2 ) +
                                         Math.pow( last_mouse_pos.y - site.y, 2 );
                  if ( undefined === closest_distance ||
                        pointer_distance < closest_distance ) {
                    closest_distance = pointer_distance;
                    closest_site = site;
                  }
                }
              }
        	  }
        	  
            for ( var i = 0, l = sites.length; i < l; i++ ) {
              var cell = diagram.cells[ sites[i].voronoiId ],
                ix = current_ids.indexOf( sites[i].voronoiId );
              if ( ix !== -1 ) {
                current_ids.splice( ix, 1 );
              }
              
              if ( cell ) {
                var halfedges = cell.halfedges,
                    fill_template = "",
                    site = sites[ i ];
                if ( site === closest_site && undefined !== last_mouse_pos ) {
                  var pointer_site = sites[ sites.length - 1 ],
                      pointer_cell = diagram.cells[ pointer_site.voronoiId ],
                      pointer_halfedges = pointer_cell.halfedges,
                      halfedge_signatures = [];
                  for ( var j in halfedges ) {
                    halfedge_signatures.push( getEdgeSignature( halfedges[ j ] ) );
                  }
                  // console.log( halfedge_signatures );
                  for ( var j in pointer_halfedges ) {
                    var signature = getEdgeSignature( pointer_halfedges[ j ] );
                    var match_index = halfedge_signatures.indexOf( signature );
                    // console.log( signature );
                    if ( match_index !== -1 ) {
                      var add_halfedges = [];
                      for ( var k = j - 1; k >= 0; --k ) {
                        add_halfedges.push( pointer_halfedges[ k ] );
                      }
                      for ( var k = pointer_halfedges.length - 1; k >= j + 1 ; --k ) {
                        add_halfedges.push( pointer_halfedges[ k ] );
                      }
                      halfedges.splice( match_index, 1 );
                      for ( var j in add_halfedges ) {
                        halfedges.splice( match_index, 0, add_halfedges[ j ] );
                      }
                      //break;
                    }
                  }
                  
                }
                
                var length = halfedges.length
                    
                if ( length > 2 ) {
                  var points = [];
                  for (var j = 0; j < length; j++) {
                    v = halfedges[j].getEndpoint();
                    points.push( v );
                  }
                  
                  if (
                    site.x > paper._left &&
                    site.x < paper._left + paper.width &&
                    site.y > paper._top &&
                    site.y < paper._top + paper.height
                  ) {
                    fill_template = "template" + ( index++ );
                  }
                  
                  paths[ i ] = setPath( points, sites[i], paths[ i ], fill_template );
                }
              }
            }
            
            // if (  undefined !== closest_site &&
            //       null !== closest_site &&
            //       null !== last_mouse_pos ) {
            //   var ex_connector = new ExPath();
            //   ex_connector.moveTo( closest_site.x, closest_site.y );
            //   ex_connector.lineTo( last_mouse_pos.x, last_mouse_pos.y );
            //   closest_center_line = paper.path( ex_connector.getPathDSL() );
            //   closest_center_line.attr( { "stroke": "#FFF", "stroke-width": 4 } );
            // }
            
            //last_path.attr( "fill", "#000" );
          }
        }
        
        function getEdgeSignature( halfedge ) {
          var x1 = halfedge.edge.va.x,
              y1 = halfedge.edge.va.y,
              x2 = halfedge.edge.vb.x,
              y2 = halfedge.edge.vb.y;
          if ( x1 > x2 ) {
            var c = x1;
            x1 = x2;
            x2 = c;
            c = y1;
            y1 = y2;
            y2 = c;
          }
          return "" + Math.round( x1 ) + "." +
                      Math.round( y1 ) + "." +
                      Math.round( x2 ) + "." +
                      Math.round( y2 );
        }

        
        function setPath( points, site, current_path, fill_template ) {
        	
        	if ( points.length <= 2 ) {
        	  return;
        	}
        	
        	var ex_p = new ExPath(),
        	    p1, p2, p3, p12, p23,
        	    points_stack = points;
        	
        	points_stack.push( points[ 0 ] );
        	points_stack.push( points[ 1 ] );
        	
        	while( points_stack.length > 2 ) {
        	  var points_set = [];
        	  p1 = { x: Math.round( points_stack[ 0 ].x ), y: Math.round( points_stack[ 0 ].y ) };
        	  p2 = { x: Math.round( points_stack[ 1 ].x ), y: Math.round( points_stack[ 1 ].y ) };
        	  p3 = { x: Math.round( points_stack[ 2 ].x ), y: Math.round( points_stack[ 2 ].y ) };
        	  p12 = { x: Math.round( ( p1.x + p2.x ) / 2 ), y: Math.round( ( p1.y + p2.y ) / 2 ) };
        	  p23 = { x: Math.round( ( p3.x + p2.x ) / 2 ), y: Math.round( ( p3.y + p2.y ) / 2 ) };
        	  
        	  if ( !ex_p.isStarted() ) {
        	    ex_p.moveTo( p12.x, p12.y );
        	  }
        	  ex_p.sCurveTo( p2.x, p2.y, p23.x, p23.y );
        	  
        	  points_stack = points_stack.slice( 1 );
        	}
        	
          ex_p.close();
          
          var path,
              path_dsl = ex_p.getPathDSL();
          if ( current_path !== undefined && current_path !== null ) {
            path = current_path;
            path.attr( "path", path_dsl );
          } else {
            path = paper.path( path_dsl );
            path.attr( "stroke", "#000" );
            path.attr( "stroke-width", 10 );
            //path.scale( 0.95 );
            path.attr( "fill", "url(#" + fill_template + ")" );
          }
          
          return path;
        }



        function generateBeeHivePoints( size, loose ) {
        	var points = [];
        	var col = { x: paper.width / size.x, y: paper.height / size.y };
        	for(var i = -1; i < size.x + 1; i++) {
        		for(var j = -1; j < size.y + 1; j++) {
        			var point = {
        			  x: ( i / size.x * paper.width + col.x / 2 ),
        			  y: ( j / size.y * paper.height + col.y / 2 )
        			}
        			if ( j % 2 ) {
        				point.x += col.x / 2;
        			}
        			if ( loose ) {
        				point.x += col.x / 4 * ( Math.random() - 1 );
        				point.y += col.y / 4 * ( Math.random() - 1 );
        			}
        			points.push( point );
        		}
        	}
        	return points;
        }
      })();
    </script>
  </body>
</html>